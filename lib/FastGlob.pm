#!/usr/local/bin/perl
package FastGlob;

require 5.005;

# ABSTRACT: A faster glob() implementation

BEGIN {
    # VERSION: generated by DZP::OurPkgVersion
}

=head1 SYNOPSIS

        use FastGlob qw(glob);
        my @list = &glob('*.c');

=head1 DESCRIPTION

This module implements globbing in perl, rather than forking a csh.
This is faster than the built-in glob() call, and more robust (on
many platforms, csh chokes on C<echo *> if too many files are in the
directory.)

There are several module-local variables that can be set for 
alternate environments, they are listed below with their (UNIX-ish)
defaults.

        $FastGlob::dirsep = '/';        # directory path separator
        $FastGlob::rootpat = '\A\Z';    # root directory prefix pattern
        $FastGlob::curdir = '.';        # name of current directory in dir
        $FastGlob::parentdir = '..';    # name of parent directory in dir
        $FastGlob::hidedotfiles = 1;    # hide filenames starting with .

So for MS-DOS for example, you could set these to:

        $FastGlob::dirsep = '\\';       # directory path separator
        $FastGlob::rootpat = '[A-Z]:';  # <Drive letter><colon> pattern
        $FastGlob::curdir = '.';        # name of current directory in dir
        $FastGlob::parentdir = '..';    # name of parent directory in dir
        $FastGlob::hidedotfiles = 0;    # hide filenames starting with .
        $FastGlob::caseinsensitive = 1; # case sensitivity

And for MacOS to:

        $FastGlob::dirsep = ':';        # directory path separator
        $FastGlob::rootpat = '\A\Z';    # root directory prefix pattern
        $FastGlob::curdir = '.';        # name of current directory in dir
        $FastGlob::parentdir = '..';    # name of parent directory in dir
        $FastGlob::hidedotfiles = 0;    # hide filenames starting with .

=head1 INSTALLATION

Copy this module to the Perl 5 Library directory.

=cut

use Exporter ();

@ISA = qw(Exporter);
@EXPORT = qw(&glob);
@EXPORT_OK = qw(dirsep rootpat curdir parentdir hidedotfiles caseinsensitive);

use 5.004;
use strict;                # be good

# platform specifics

our $dirsep = '/';
our $rootpat= '\A\Z';
our $curdir = '.';
our $parentdir = '..';
our $hidedotfiles = 1;
our $caseinsensitive = 0;
our $verbose = $ENV{'DEBUG_FASTGLOB'} || 0;

# Defaults for Windows platforms
if ($^O eq 'MSWin32') {
    $dirsep = "\\\/";        
    $rootpat = '[a-zA-Z]:';  
    $curdir = '.';        
    $parentdir = '..';    
    $hidedotfiles = 0;    
    $caseinsensitive = 1; 
}

#
# recursively wildcard expand a list of strings
#

sub glob($) {

    my @res; 
    my $part;
    my $found1;
    my $out;
    my $bracepat = qr(\{([^\{\}]*)\});

    # deal with {xxx,yyy,zzz} 
    @res = ();
    $found1 = 1;
    while ($found1) {
    $found1 = 0;
    for (@_) {
        if ( m{$bracepat} ) {
            foreach $part (split(',',$1)) {
                $out = $_;
                $out =~ s/$bracepat/$part/;
                push(@res, $out);
            }
            $found1 = 1;
        } else {
            push(@res, $_);
        }
    }
        @_ = @res;
        @res = ();
    }

    for (@_) {
        # check for and do  tilde expansion
        if ( /^\~([^\Q${dirsep}\E]*)/ ) {
            my $usr = $1;
            my $usrdir = ( ($1 eq "") ? getpwuid($<) : getpwnam($usr) )[7];
            if ($usrdir ne "" ) {
                    s/^\~\Q$usr\E/$usrdir/;
            push(@res, $_);
            }
        } else {
            push(@res, $_);
            }
    }
    @_ = @res;
    @res = ();

    for (@_) {
        # if there's no wildcards, just return it
            unless (/(^|[^\\])[*?\[\]{}]/) {
                push (@res, $_);
                next;
            }

        # debugging
        print __LINE__.": regexp is $_\n" if ($verbose);

        # now split it into directory components
        # we need to do this before we process
        # regex as dirsep may be backslash and
        # that would clash with backslash used for 
        # escaping
        my @comps = split(/[\Q$dirsep\E]/);

        map {

            # deal with dot files

            # Make the glob into a regexp
            # escape + , and | 
            s/([+.|])/\\$1/go;

            # handle * and ?
            s/(?<!\\)(\*)/.*/go;
            s/(?<!\\)(\?)/./go;

            if ( $hidedotfiles ) {
                s/(\A|\Q$dirsep\E)\.\*/$1(?:^[^.].*)/go;
                s/(\A|\Q$dirsep\E)\./$1\[\^.\]/go;
                s/(\A|\Q$dirsep\E)\[\^([^].]*)\]/$1\[\^\\.$2\]/go;
            }

        } @comps;

        if ($verbose) {
            print __LINE__.": comps are " . join(", ", map {
                "|$_|";
            } @comps) . "\n";
        }

        if ( $comps[0] =~ /($rootpat)/ ) {
            shift(@comps);
            push(@res, &recurseglob( "$1$dirsep", "$1$dirsep" , @comps ));
        }
        else {
            push(@res, &recurseglob( $curdir, '' , @comps ));
        }
    }
    return sort(@res);
}

sub recurseglob($ $ @) {
    my($dir, $dirname, @comps) = @_;
    my(@res) = ();
    my($re, $anymatches, @names);

    if ( @comps == 0 || ! -d $dir) {
        # bottom of recursion, just return the path 
        chop($dirname);  # always has gratiutous trailing slash
        @res = ($dirname);
    } elsif ($comps[0] eq '') {
        shift(@comps);
        unshift(@res, &recurseglob( "$dir$dirsep", 
                    "$dirname$dirsep",
                    @comps ));
    } else {
        my $matchname = shift(@comps);
        $re = '\A' . $matchname . '\Z';
$re = $matchname;

        # don't read the directory if have an exact match
        if ($matchname =~ m/^[a-z0-9_]+$/i && -e "$dirname$matchname") {
                @names = $matchname;
        } else {
            # slurp in the directory
            opendir(HANDLE, $dir);
            @names = readdir(HANDLE);
            closedir(HANDLE);
        }


        # look for matches, and if you find one, glob the rest of the
        # components. We eval the loop so the regexp gets compiled in,
        # making searches on large directories faster.
        # handle case insensitivity
        $anymatches = 0;
        my $regex;
        if ($caseinsensitive) {
                print __LINE__.": dir is $dir, component re is qr/$re/i\n" if ($verbose);
                $regex = qr/$re/i;
        } else {
                print __LINE__.": dir is $dir, component re is qr{$re}\n" if ($verbose);
                $regex = qr{$re};
        }
        foreach (@names) {
            print __LINE__.": considering |$_|\n" if ($verbose);
            if ( m{$regex} ) {
                if ( $_ ne "$curdir" and $_ ne "$parentdir" && (! -d "$dirname$_" && scalar @comps)) {

                    # if we have a non-directory we want to add it
                    # to the result only if it matches the next regex

                    my $matchname = $comps[0];
                    my $subre = '\A' . $matchname . '\Z';
                    my $subregex;
                    if ($caseinsensitive) {
                            print __LINE__.": dir is $dir, component re is qr/$re/i\n" if ($verbose);
                            $subregex = qr/$re/i;
                    } else {
                            print __LINE__.":dir is $dir, component re is qr{$re}\n" if ($verbose);
                            my $subregex = qr{$re};
                    }

                    if ( "$dirname$_" =~ m{$subregex}  && scalar @comps == 0) {
                        unshift(@res, "$dirname$_");
                    }
                } elsif ( $#comps > -1 ) {
                    unshift(@res, &recurseglob( "$dir$dirsep$_", 
                                "$dirname$_$dirsep",
                                @comps ));
                } else {
                    unshift(@res, "$dirname$_" );
                }
                $anymatches = 1;
            }
        }
    }
    return @res;
}


#
# If we are a script then return glob with each cmdline-arg
#
unless (caller) {
    $FastGlob::hidedotfiles = 1;    # hide filenames starting with .
    my $opt_0 = ($ARGV[0] eq '-0') ? defined(shift) : 0;
    my @globbed = ();
    my @errmsgs = ();
    my $matches = 0;
    for (@ARGV) {
        for my $f (&glob($_)) {
            print "$f\n";
        }
    }
}
1;
__END__
